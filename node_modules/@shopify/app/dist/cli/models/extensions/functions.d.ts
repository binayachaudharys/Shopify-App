/// <reference types="node" />
import { BaseFunctionConfigurationSchema, ZodSchemaType } from './schemas.js';
import { ExtensionCategory, GenericSpecification, FunctionExtension } from '../app/extensions.js';
import { schema, abort } from '@shopify/cli-kit';
import { Writable } from 'stream';
export declare type FunctionConfigType = schema.define.infer<typeof BaseFunctionConfigurationSchema>;
/**
 * Specification with all the needed properties and methods to load a function.
 */
export interface FunctionSpec<TConfiguration extends FunctionConfigType = FunctionConfigType> extends GenericSpecification {
    identifier: string;
    externalIdentifier: string;
    externalName: string;
    helpURL?: string;
    gated: boolean;
    templateURL?: string;
    supportedFlavors: {
        name: string;
        value: string;
    }[];
    configSchema: ZodSchemaType<TConfiguration>;
    registrationLimit: number;
    templatePath: (lang: string) => string;
    category: () => ExtensionCategory;
}
/**
 * Class that represents an instance of a local function
 * Before creating this class we've validated that:
 * - There is a spec for this type of function
 * - The Config Schema for that spec is followed by the function config toml file
 *
 * This class holds the public interface to interact with functions
 */
export declare class FunctionInstance<TConfiguration extends FunctionConfigType = FunctionConfigType> implements FunctionExtension {
    idEnvironmentVariableName: string;
    localIdentifier: string;
    directory: string;
    configuration: TConfiguration;
    configurationPath: string;
    private specification;
    constructor(options: {
        configuration: TConfiguration;
        configurationPath: string;
        specification: FunctionSpec<TConfiguration>;
        directory: string;
    });
    get graphQLType(): string;
    get identifier(): string;
    get type(): string;
    get externalType(): string;
    get name(): string;
    inputQueryPath(): string;
    buildWasmPath(): string;
    build(stdout: Writable, stderr: Writable, signal: abort.Signal): Promise<void>;
    publishURL(options: {
        orgId: string;
        appId: string;
    }): Promise<string>;
}
/**
 * Find the registered spec for a given function type
 */
export declare function functionSpecForType(type: string): Promise<FunctionSpec | undefined>;
export declare function createFunctionSpec<TConfiguration extends FunctionConfigType = FunctionConfigType>(spec: {
    identifier: string;
    externalIdentifier: string;
    externalName: string;
    helpURL?: string;
    gated?: boolean;
    templateURL?: string;
    supportedFlavors?: {
        name: string;
        value: string;
    }[];
    registrationLimit?: number;
    configSchema?: ZodSchemaType<TConfiguration>;
    templatePath: (lang: string) => string;
}): FunctionSpec;
