import { allUISpecifications } from './specifications.js';
import { blocks, defualtExtensionFlavors } from '../../constants.js';
import { id, path, output, environment, string } from '@shopify/cli-kit';
import { ok } from '@shopify/cli-kit/node/result';
/**
 * Class that represents an instance of a local extension
 * Before creating this class we've validated that:
 * - There is a spec for this type of extension
 * - The Schema for that spec is followed by the extension config toml file
 * - We were able to find an entry point file for that extension
 *
 * It supports extension points, making this Class compatible with both new ui-extension
 * and legacy extension types. Extension points are optional and this class will handle them if present.
 *
 * This class holds the public interface to interact with extensions
 */
export class UIExtensionInstance {
    constructor(options) {
        this.configuration = options.configuration;
        this.configurationPath = options.configurationPath;
        this.entrySourceFilePath = options.entryPath;
        this.directory = options.directory;
        this.specification = options.specification;
        this.remoteSpecification = options.remoteSpecification;
        this.outputBundlePath = path.join(options.directory, 'dist/main.js');
        this.devUUID = `dev-${id.generateRandomUUID()}`;
        this.localIdentifier = path.basename(options.directory);
        this.idEnvironmentVariableName = `SHOPIFY_${string.constantize(path.basename(this.directory))}_ID`;
    }
    get graphQLType() {
        return (this.specification.graphQLType ?? this.specification.identifier).toUpperCase();
    }
    get identifier() {
        return this.specification.identifier;
    }
    get type() {
        return this.specification.identifier;
    }
    get humanName() {
        return this.remoteSpecification?.externalName ?? this.specification.externalName;
    }
    get name() {
        return this.configuration.name;
    }
    get dependency() {
        return this.specification.dependency;
    }
    get externalType() {
        return this.remoteSpecification?.externalIdentifier ?? this.specification.externalIdentifier;
    }
    get surface() {
        return this.specification.surface;
    }
    deployConfig() {
        return this.specification.deployConfig?.(this.configuration, this.directory) ?? Promise.resolve({});
    }
    validate() {
        if (!this.specification.validate)
            return Promise.resolve(ok(undefined));
        return this.specification.validate(this.configuration, this.directory);
    }
    preDeployValidation() {
        if (!this.specification.preDeployValidation)
            return Promise.resolve();
        return this.specification.preDeployValidation(this.configuration);
    }
    async publishURL(options) {
        const partnersFqdn = await environment.fqdn.partners();
        const parnersPath = this.specification.partnersWebIdentifier;
        return `https://${partnersFqdn}/${options.orgId}/apps/${options.appId}/extensions/${parnersPath}/${options.extensionId}`;
    }
    previewMessage(url, storeFqdn) {
        const heading = output.token.heading(`${this.name} (${this.humanName})`);
        let message = output.content `Preview link: ${url}/extensions/${this.devUUID}`;
        if (this.specification.previewMessage) {
            const customMessage = this.specification.previewMessage(url, this.devUUID, this.configuration, storeFqdn);
            if (!customMessage)
                return;
            message = customMessage;
        }
        return output.content `${heading}\n${message.value}\n`;
    }
    getBundleExtensionStdinContent() {
        if (this.specification.getBundleExtensionStdinContent) {
            return this.specification.getBundleExtensionStdinContent(this.configuration);
        }
        const relativeImportPath = this.entrySourceFilePath?.replace(this.directory, '');
        return `import '.${relativeImportPath}';`;
    }
    shouldFetchCartUrl() {
        return this.specification.shouldFetchCartUrl?.(this.configuration) || false;
    }
    hasExtensionPointTarget(target) {
        return this.specification.hasExtensionPointTarget?.(this.configuration, target) || false;
    }
}
/**
 * Find the registered spececification for a given extension type
 */
export async function uiSpecForType(type) {
    const allSpecs = await allUISpecifications();
    return allSpecs.find((spec) => spec.identifier === type || spec.externalIdentifier === type);
}
// PENDING: Fetch remote specs
function remoteSpecForType(type) {
    return undefined;
}
export function createUIExtensionSpec(spec) {
    const defaults = {
        showInCLIHelp: true,
        singleEntryPath: true,
        gated: false,
        registrationLimit: blocks.extensions.defaultRegistrationLimit,
        supportedFlavors: defualtExtensionFlavors,
        category: () => (spec.identifier === 'theme' ? 'theme' : 'ui'),
    };
    return { ...defaults, ...spec };
}
//# sourceMappingURL=ui.js.map